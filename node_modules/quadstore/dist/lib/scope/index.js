"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Scope = void 0;
const leveliterator_1 = require("../get/leveliterator");
const utils_1 = require("../utils");
class Scope {
    constructor(factory, id, blankNodes) {
        this.blankNodes = blankNodes;
        this.factory = factory;
        this.id = id;
    }
    static async init(store) {
        return new Scope(store.dataFactory, utils_1.nanoid(), new Map());
    }
    static async load(store, scopeId) {
        const levelOpts = Scope.getLevelIteratorOpts(false, true, scopeId);
        const iterator = new leveliterator_1.LevelIterator(store.db.iterator(levelOpts), (key, value) => value);
        const blankNodes = new Map();
        const { dataFactory: factory } = store;
        await utils_1.consumeOneByOne(iterator, (value) => {
            const { originalLabel, randomLabel } = JSON.parse(value);
            blankNodes.set(originalLabel, factory.blankNode(randomLabel));
        });
        return new Scope(factory, scopeId, blankNodes);
    }
    static async delete(store, scopeId) {
        const batch = store.db.batch();
        const levelOpts = Scope.getLevelIteratorOpts(true, false, scopeId);
        const iterator = new leveliterator_1.LevelIterator(store.db.iterator(levelOpts), (key, value) => key);
        await utils_1.consumeOneByOne(iterator, (key) => {
            batch.del(key);
        });
        await utils_1.pFromCallback((cb) => { batch.write(cb); });
    }
    static getLevelIteratorOpts(keys, values, scopeId) {
        const gte = scopeId
            ? `SCOPE${utils_1.separator}${scopeId}${utils_1.separator}`
            : `SCOPE${utils_1.separator}`;
        return {
            keys,
            values,
            keyAsBuffer: false,
            valueAsBuffer: false,
            gte,
            lte: `${gte}${utils_1.boundary}`,
        };
    }
    static addMappingToLevelBatch(scopeId, batch, originalLabel, randomLabel) {
        batch.put(`SCOPE${utils_1.separator}${scopeId}${utils_1.separator}${originalLabel}`, JSON.stringify({ originalLabel, randomLabel }));
    }
    parseBlankNode(node, batch) {
        let cachedNode = this.blankNodes.get(node.value);
        if (!cachedNode) {
            cachedNode = this.factory.blankNode(utils_1.nanoid());
            this.blankNodes.set(node.value, cachedNode);
            Scope.addMappingToLevelBatch(this.id, batch, node.value, cachedNode.value);
        }
        return cachedNode;
    }
    parseSubject(node, batch) {
        switch (node.termType) {
            case 'BlankNode':
                return this.parseBlankNode(node, batch);
            default:
                return node;
        }
    }
    parseObject(node, batch) {
        switch (node.termType) {
            case 'BlankNode':
                return this.parseBlankNode(node, batch);
            default:
                return node;
        }
    }
    parseGraph(node, batch) {
        switch (node.termType) {
            case 'BlankNode':
                return this.parseBlankNode(node, batch);
            default:
                return node;
        }
    }
    parseQuad(quad, batch) {
        return this.factory.quad(this.parseSubject(quad.subject, batch), quad.predicate, this.parseObject(quad.object, batch), this.parseGraph(quad.graph, batch));
    }
}
exports.Scope = Scope;
//# sourceMappingURL=index.js.map