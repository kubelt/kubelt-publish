"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const quadstore_1 = require("./quadstore");
const memdown_1 = __importDefault(require("memdown"));
const types_1 = require("./types");
const rdf_data_factory_1 = require("rdf-data-factory");
const utils_1 = require("./utils");
const quadstore_comunica_1 = require("quadstore-comunica");
class RdfStoreQueryEngine {
    async parse(queryString, options) {
    }
    async query(data, queryString, options) {
        const store = new quadstore_1.Quadstore({
            dataFactory: new rdf_data_factory_1.DataFactory(),
            backend: memdown_1.default(),
            comunica: quadstore_comunica_1.newEngine(),
        });
        await store.open();
        await store.multiPut(data);
        const results = await store.sparql(queryString);
        let preparedResults;
        switch (results.type) {
            case types_1.ResultType.BINDINGS:
                preparedResults = await this.prepareBindingResult(store, results);
                break;
            case types_1.ResultType.QUADS:
                preparedResults = await this.prepareQuadResult(store, results);
                break;
            default:
                throw new Error(`Unsupported`);
        }
        await store.close();
        return preparedResults;
    }
    async prepareBindingResult(store, result) {
        return {
            type: 'bindings',
            value: result.items,
            checkOrder: false,
            variables: result.variables,
            equals: (that, laxCardinality) => {
                if (that.type !== 'bindings') {
                    return false;
                }
                return this.compareBindingResult(store, result.items, that.value, result.variables, laxCardinality);
            },
        };
    }
    compareBindingResult(store, actualBindings, expectedBindings, variables, laxCardinality) {
        const comparator = utils_1.getBindingComparator(variables);
        actualBindings.sort(comparator);
        expectedBindings.sort(comparator);
        for (let i = 0, n = Math.min(actualBindings.length, expectedBindings.length); i < n; i += 1) {
            if (comparator(actualBindings[i], expectedBindings[i]) !== 0) {
                return false;
            }
        }
        return true;
    }
    async prepareQuadResult(store, result) {
        return {
            type: 'quads',
            value: result.items,
            equals: (that, laxCardinality) => {
                if (that.type !== 'quads') {
                    return false;
                }
                return this.compareQuadResult(store, result.items, that.value, laxCardinality);
            },
        };
    }
    compareQuadResult(store, actualQuads, expectedQuads, laxCardinality) {
        const comparator = utils_1.getQuadComparator();
        actualQuads.sort(comparator);
        expectedQuads.sort(comparator);
        for (let i = 0, n = Math.min(actualQuads.length, expectedQuads.length); i < n; i += 1) {
            if (comparator(actualQuads[i], expectedQuads[i]) !== 0) {
                return false;
            }
        }
        return true;
    }
}
module.exports = new RdfStoreQueryEngine();
//# sourceMappingURL=engine.js.map