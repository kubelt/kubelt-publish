"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleQuery = exports.fillPatternWithBinding = exports.handleSimpleDeleteInsert = void 0;
const types_1 = require("../types");
const utils_1 = require("../utils");
const patternToQuad = (pattern) => {
    return pattern;
};
const handleSimpleDeleteInsert = async (store, operation) => {
    return await store.multiPatch(operation.delete ? operation.delete.map(patternToQuad) : utils_1.emptyArray, operation.insert ? operation.insert.map(patternToQuad) : utils_1.emptyArray, utils_1.emptyObject);
};
exports.handleSimpleDeleteInsert = handleSimpleDeleteInsert;
const fillPatternWithBinding = (pattern, binding) => {
    const quad = { ...pattern };
    if (pattern.subject && pattern.subject.termType === 'Variable') {
        quad.subject = binding[`?${pattern.subject.value}`];
    }
    if (pattern.predicate && pattern.predicate.termType === 'Variable') {
        quad.predicate = binding[`?${pattern.predicate.value}`];
    }
    if (pattern.object && pattern.object.termType === 'Variable') {
        quad.object = binding[`?${pattern.object.value}`];
    }
    if (pattern.graph && pattern.graph.termType === 'Variable') {
        quad.graph = binding[`?${pattern.graph.value}`];
    }
    return quad;
};
exports.fillPatternWithBinding = fillPatternWithBinding;
const handleQuery = async (store, operation) => {
    if (!operation.where) {
        return await exports.handleSimpleDeleteInsert(store, operation);
    }
    const results = await store.sparql(operation.where);
    if (results.type !== types_1.ResultType.BINDINGS) {
        throw new Error(`Unsupported result type "${results.type}"`);
    }
    let oldQuads = utils_1.emptyArray;
    let newQuads = utils_1.emptyArray;
    if (operation.delete) {
        oldQuads = utils_1.flatMap(results.items, (binding) => {
            return operation.delete.map(pattern => exports.fillPatternWithBinding(pattern, binding));
        });
    }
    if (operation.insert) {
        newQuads = utils_1.flatMap(results.items, (binding) => {
            return operation.insert.map(pattern => exports.fillPatternWithBinding(pattern, binding));
        });
    }
    return store.multiPatch(oldQuads, newQuads, utils_1.emptyObject);
};
exports.handleQuery = handleQuery;
//# sourceMappingURL=deleteInsert.js.map