/// <reference types="node" />
import type { DataFactory, Quad, Quad_Graph, Quad_Object, Quad_Predicate, Quad_Subject, Store, Stream } from 'rdf-js';
import type { DelStreamOpts, DelOpts, PutOpts, PatchOpts, GetOpts, InternalIndex, PutStreamOpts, BindingArrayResult, BindingStreamResult, BooleanResult, Pattern, QuadArrayResult, QuadStreamResult, StoreOpts, VoidResult, TSReadable, SparqlOpts, TermName, Prefixes } from './types';
import type { IQueryEngine } from '@comunica/types';
import type { Algebra } from 'sparqlalgebrajs';
import { EventEmitter } from 'events';
import { AbstractLevelDOWN } from 'abstract-leveldown';
import { Scope } from './scope';
export declare class Quadstore implements Store {
    readonly db: AbstractLevelDOWN;
    readonly indexes: InternalIndex[];
    readonly id: string;
    readonly comunica?: IQueryEngine;
    readonly prefixes: Prefixes;
    readonly dataFactory: DataFactory;
    constructor(opts: StoreOpts);
    protected ensureReady(): void;
    protected ensureComunica(): IQueryEngine;
    protected waitForStatus(status: string, timeout?: number): Promise<void>;
    open(): Promise<void>;
    close(): Promise<void>;
    toString(): string;
    toJSON(): string;
    _addIndex(terms: TermName[]): void;
    clear(): Promise<void>;
    match(subject?: Quad_Subject, predicate?: Quad_Predicate, object?: Quad_Object, graph?: Quad_Graph, opts?: GetOpts): Stream<Quad>;
    countQuads(subject?: Quad_Subject, predicate?: Quad_Predicate, object?: Quad_Object, graph?: Quad_Graph, opts?: GetOpts): Promise<number>;
    import(source: Stream<Quad>): EventEmitter;
    remove(source: Stream<Quad>): EventEmitter;
    removeMatches(subject?: Quad_Subject, predicate?: Quad_Predicate, object?: Quad_Object, graph?: Quad_Graph, opts?: GetOpts): EventEmitter;
    deleteGraph(graph: Quad_Graph): EventEmitter;
    getApproximateSize(pattern: Pattern, opts?: GetOpts): Promise<import("./types").ApproximateSizeResult>;
    sparql(query: Algebra.Operation | string, opts?: SparqlOpts): Promise<QuadArrayResult | BindingArrayResult | VoidResult | BooleanResult>;
    put(quad: Quad, opts?: PutOpts): Promise<VoidResult>;
    multiPut(quads: Quad[], opts?: PutOpts): Promise<VoidResult>;
    del(quad: Quad, opts?: DelOpts): Promise<VoidResult>;
    multiDel(quads: Quad[], opts?: DelOpts): Promise<VoidResult>;
    patch(oldQuad: Quad, newQuad: Quad, opts?: PatchOpts): Promise<VoidResult>;
    multiPatch(oldQuads: Quad[], newQuads: Quad[], opts?: PatchOpts): Promise<VoidResult>;
    private writeBatch;
    get(pattern: Pattern, opts?: GetOpts): Promise<QuadArrayResult>;
    getStream(pattern: Pattern, opts?: GetOpts): Promise<QuadStreamResult>;
    putStream(source: TSReadable<Quad>, opts?: PutStreamOpts): Promise<VoidResult>;
    delStream(source: TSReadable<Quad>, opts?: DelStreamOpts): Promise<VoidResult>;
    sparqlStream(query: Algebra.Operation | string, opts?: SparqlOpts): Promise<QuadStreamResult | BindingStreamResult | VoidResult | BooleanResult>;
    initScope(): Promise<Scope>;
    loadScope(scopeId: string): Promise<Scope>;
    deleteScope(scopeId: string): Promise<void>;
    deleteAllScopes(): Promise<void>;
}
