'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.Quadstore = void 0;
const types_1 = require("./types");
const events_1 = require("events");
const asynciterator_1 = require("asynciterator");
const utils_1 = require("./utils");
const get_1 = require("./get");
const sparql_1 = require("./sparql");
const rdf_data_factory_1 = require("rdf-data-factory");
const scope_1 = require("./scope");
const serialization_1 = require("./serialization");
const __value = Buffer.alloc(32);
class Quadstore {
    constructor(opts) {
        this.dataFactory = opts.dataFactory || new rdf_data_factory_1.DataFactory();
        this.db = opts.backend;
        this.indexes = [];
        this.id = utils_1.nanoid();
        (opts.indexes || utils_1.defaultIndexes)
            .forEach((index) => this._addIndex(index));
        this.comunica = opts.comunica;
        this.prefixes = opts.prefixes || {
            expandTerm: term => term,
            compactIri: iri => iri,
        };
    }
    ensureReady() {
        if (this.db.status !== 'open') {
            throw new Error(`Store is not ready (status: "${this.db.status}"). Did you call store.open()?`);
        }
    }
    ensureComunica() {
        if (!this.comunica) {
            throw new Error('SPARQL feature are disabled as no Comunica engine was passed to the Quadstore() constructor');
        }
        return this.comunica;
    }
    waitForStatus(status, timeout = 200) {
        return new Promise((resolve, reject) => {
            const t = setTimeout(() => {
                clearInterval(i);
                clearTimeout(t);
                reject(new Error(`Timeout while waiting for status "${status}"`));
            }, timeout);
            const i = setInterval(() => {
                if (this.db.status === status) {
                    clearInterval(i);
                    clearTimeout(t);
                    resolve();
                }
            }, 10);
        });
    }
    async open() {
        switch (this.db.status) {
            case 'closing':
                await this.waitForStatus('closed');
            case 'new':
            case 'closed':
                await utils_1.pFromCallback((cb) => { this.db.open(cb); });
                break;
            case 'opening':
                await this.waitForStatus('open');
                break;
            case 'open':
            default:
        }
    }
    async close() {
        switch (this.db.status) {
            case 'opening':
                await this.waitForStatus('open');
            case 'open':
            case 'new':
                await utils_1.pFromCallback((cb) => { this.db.close(cb); });
                break;
            case 'closing':
                await this.waitForStatus('closed');
                break;
            case 'closed':
            default:
        }
    }
    toString() {
        return this.toJSON();
    }
    toJSON() {
        return `[object ${this.constructor.name}::${this.id}]`;
    }
    _addIndex(terms) {
        const name = terms.map(t => t.charAt(0).toUpperCase()).join('');
        this.indexes.push({
            terms,
            prefix: name + utils_1.separator,
        });
    }
    async clear() {
        if (typeof this.db.clear === 'function') {
            return new Promise((resolve, reject) => {
                this.db.clear((err) => {
                    err ? reject(err) : resolve();
                });
            });
        }
        await this.delStream((await this.getStream({})).iterator, { batchSize: 20 });
    }
    match(subject, predicate, object, graph, opts = utils_1.emptyObject) {
        if (subject && subject.termType === 'Literal') {
            return new asynciterator_1.EmptyIterator();
        }
        const pattern = { subject, predicate, object, graph };
        return new asynciterator_1.TransformIterator(this.getStream(pattern, opts).then(results => results.iterator));
    }
    async countQuads(subject, predicate, object, graph, opts = utils_1.emptyObject) {
        if (subject && subject.termType === 'Literal') {
            return 0;
        }
        const pattern = { subject, predicate, object, graph };
        const results = await this.getApproximateSize(pattern, opts);
        return results.approximateSize;
    }
    import(source) {
        const emitter = new events_1.EventEmitter();
        this.putStream(source, {})
            .then(() => { emitter.emit('end'); })
            .catch((err) => { emitter.emit('error', err); });
        return emitter;
    }
    remove(source) {
        const emitter = new events_1.EventEmitter();
        this.delStream(source, {})
            .then(() => emitter.emit('end'))
            .catch((err) => emitter.emit('error', err));
        return emitter;
    }
    removeMatches(subject, predicate, object, graph, opts = utils_1.emptyObject) {
        const source = this.match(subject, predicate, object, graph, opts);
        return this.remove(source);
    }
    deleteGraph(graph) {
        return this.removeMatches(undefined, undefined, undefined, graph);
    }
    async getApproximateSize(pattern, opts = utils_1.emptyObject) {
        await this.ensureReady();
        return await get_1.getApproximateSize(this, pattern, opts);
    }
    async sparql(query, opts = utils_1.emptyObject) {
        this.ensureReady();
        return await sparql_1.sparql(this, this.ensureComunica(), query, opts);
    }
    async put(quad, opts = utils_1.emptyObject) {
        this.ensureReady();
        let batch = this.db.batch();
        if (opts.scope) {
            quad = opts.scope.parseQuad(quad, batch);
        }
        batch = this.indexes.reduce((indexBatch, index) => {
            const key = serialization_1.quadWriter.write(index.prefix, __value, quad, index.terms, this.prefixes);
            return indexBatch.put(key, serialization_1.copyBuffer(__value, 0, serialization_1.quadWriter.writtenValueBytes));
        }, batch);
        await this.writeBatch(batch, opts);
        return { type: types_1.ResultType.VOID };
    }
    async multiPut(quads, opts = utils_1.emptyObject) {
        this.ensureReady();
        let batch = this.db.batch();
        batch = quads.reduce((quadBatch, quad) => {
            if (opts.scope) {
                quad = opts.scope.parseQuad(quad, batch);
            }
            return this.indexes.reduce((indexBatch, index) => {
                const key = serialization_1.quadWriter.write(index.prefix, __value, quad, index.terms, this.prefixes);
                return indexBatch.put(key, serialization_1.copyBuffer(__value, 0, serialization_1.quadWriter.writtenValueBytes));
            }, quadBatch);
        }, batch);
        await this.writeBatch(batch, opts);
        return { type: types_1.ResultType.VOID };
    }
    async del(quad, opts = utils_1.emptyObject) {
        this.ensureReady();
        const batch = this.indexes.reduce((indexBatch, index) => {
            const key = serialization_1.quadWriter.write(index.prefix, __value, quad, index.terms, this.prefixes);
            return indexBatch.del(key);
        }, this.db.batch());
        await this.writeBatch(batch, opts);
        return { type: types_1.ResultType.VOID };
    }
    async multiDel(quads, opts = utils_1.emptyObject) {
        this.ensureReady();
        const batch = quads.reduce((quadBatch, quad) => {
            return this.indexes.reduce((indexBatch, index) => {
                const key = serialization_1.quadWriter.write(index.prefix, __value, quad, index.terms, this.prefixes);
                return indexBatch.del(key);
            }, quadBatch);
        }, this.db.batch());
        await this.writeBatch(batch, opts);
        return { type: types_1.ResultType.VOID };
    }
    async patch(oldQuad, newQuad, opts = utils_1.emptyObject) {
        this.ensureReady();
        const batch = this.indexes.reduce((indexBatch, index) => {
            const oldKey = serialization_1.quadWriter.write(index.prefix, __value, oldQuad, index.terms, this.prefixes);
            indexBatch.del(oldKey);
            const newKey = serialization_1.quadWriter.write(index.prefix, __value, newQuad, index.terms, this.prefixes);
            return indexBatch.put(newKey, serialization_1.copyBuffer(__value, 0, serialization_1.quadWriter.writtenValueBytes));
        }, this.db.batch());
        await this.writeBatch(batch, opts);
        return { type: types_1.ResultType.VOID };
    }
    async multiPatch(oldQuads, newQuads, opts = utils_1.emptyObject) {
        this.ensureReady();
        let batch = this.db.batch();
        batch = oldQuads.reduce((quadBatch, oldQuad) => {
            return this.indexes.reduce((indexBatch, index) => {
                const oldKey = serialization_1.quadWriter.write(index.prefix, __value, oldQuad, index.terms, this.prefixes);
                return indexBatch.del(oldKey);
            }, quadBatch);
        }, batch);
        batch = newQuads.reduce((quadBatch, newQuad) => {
            return this.indexes.reduce((indexBatch, index) => {
                const key = serialization_1.quadWriter.write(index.prefix, __value, newQuad, index.terms, this.prefixes);
                return indexBatch.put(key, serialization_1.copyBuffer(__value, 0, serialization_1.quadWriter.writtenValueBytes));
            }, quadBatch);
        }, batch);
        await this.writeBatch(batch, opts);
        return { type: types_1.ResultType.VOID };
    }
    async writeBatch(batch, opts) {
        if (opts.preWrite) {
            await opts.preWrite(batch);
        }
        await utils_1.pFromCallback((cb) => { batch.write(cb); });
    }
    async get(pattern, opts = utils_1.emptyObject) {
        this.ensureReady();
        const results = await this.getStream(pattern, opts);
        const items = await utils_1.streamToArray(results.iterator);
        return { type: results.type, items };
    }
    async getStream(pattern, opts = utils_1.emptyObject) {
        this.ensureReady();
        return await get_1.getStream(this, pattern, opts);
    }
    async putStream(source, opts = utils_1.emptyObject) {
        this.ensureReady();
        const batchSize = opts.batchSize || 1;
        if (batchSize === 1) {
            await utils_1.consumeOneByOne(source, quad => this.put(quad, opts));
        }
        else {
            await utils_1.consumeInBatches(source, batchSize, quads => this.multiPut(quads, opts));
        }
        return { type: types_1.ResultType.VOID };
    }
    async delStream(source, opts = utils_1.emptyObject) {
        this.ensureReady();
        const batchSize = opts.batchSize || 1;
        if (batchSize === 1) {
            await utils_1.consumeOneByOne(source, quad => this.del(quad));
        }
        else {
            await utils_1.consumeInBatches(source, batchSize, quads => this.multiDel(quads));
        }
        return { type: types_1.ResultType.VOID };
    }
    async sparqlStream(query, opts = utils_1.emptyObject) {
        this.ensureReady();
        return await sparql_1.sparqlStream(this, this.ensureComunica(), query, opts);
    }
    async initScope() {
        await this.ensureReady();
        return await scope_1.Scope.init(this);
    }
    async loadScope(scopeId) {
        await this.ensureReady();
        return await scope_1.Scope.load(this, scopeId);
    }
    async deleteScope(scopeId) {
        await this.ensureReady();
        await scope_1.Scope.delete(this, scopeId);
    }
    async deleteAllScopes() {
        await this.ensureReady();
        await scope_1.Scope.delete(this);
    }
}
exports.Quadstore = Quadstore;
//# sourceMappingURL=quadstore.js.map