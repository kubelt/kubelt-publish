"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.quadReader = exports.quadWriter = void 0;
const xsd = __importStar(require("./xsd"));
const fpstring_1 = require("./fpstring");
const utils_1 = require("../utils");
const terms_1 = require("./terms");
exports.quadWriter = {
    writtenValueBytes: 0,
    write(prefix, value, quad, termNames, prefixes) {
        let ret = prefix;
        let valueOffset = 0;
        for (let t = 0, term; t < termNames.length; t += 1) {
            term = quad[termNames[t]];
            switch (term.termType) {
                case 'NamedNode':
                    value.writeUInt16LE(0, valueOffset);
                    valueOffset += 2;
                    ret += terms_1.namedNodeWriter.write(value, valueOffset, term, prefixes);
                    valueOffset += terms_1.namedNodeWriter.writtenValueBytes;
                    break;
                case 'BlankNode':
                    value.writeUInt16LE(1, valueOffset);
                    valueOffset += 2;
                    ret += terms_1.blankNodeWriter.write(value, valueOffset, term);
                    valueOffset += terms_1.blankNodeWriter.writtenValueBytes;
                    break;
                case 'DefaultGraph':
                    value.writeUInt16LE(6, valueOffset);
                    valueOffset += 2;
                    ret += terms_1.defaultGraphWriter.write(value, valueOffset, term);
                    valueOffset += terms_1.defaultGraphWriter.writtenValueBytes;
                    break;
                case 'Literal':
                    if (term.language) {
                        value.writeUInt16LE(4, valueOffset);
                        valueOffset += 2;
                        ret += terms_1.langStringLiteralWriter.write(value, valueOffset, term, utils_1.separator);
                        valueOffset += terms_1.langStringLiteralWriter.writtenValueBytes;
                    }
                    else if (term.datatype) {
                        switch (term.datatype.value) {
                            case xsd.string:
                                value.writeUInt16LE(3, valueOffset);
                                valueOffset += 2;
                                ret += terms_1.stringLiteralWriter.write(value, valueOffset, term);
                                valueOffset += terms_1.stringLiteralWriter.writtenValueBytes;
                                break;
                            case xsd.integer:
                            case xsd.double:
                            case xsd.decimal:
                            case xsd.nonPositiveInteger:
                            case xsd.negativeInteger:
                            case xsd.long:
                            case xsd.int:
                            case xsd.short:
                            case xsd.byte:
                            case xsd.nonNegativeInteger:
                            case xsd.unsignedLong:
                            case xsd.unsignedInt:
                            case xsd.unsignedShort:
                            case xsd.unsignedByte:
                            case xsd.positiveInteger:
                                value.writeUInt16LE(5, valueOffset);
                                valueOffset += 2;
                                ret += terms_1.numericLiteralWriter.write(value, valueOffset, term, utils_1.separator, fpstring_1.encode(term.value), false);
                                valueOffset += terms_1.numericLiteralWriter.writtenValueBytes;
                                break;
                            case xsd.dateTime:
                                value.writeUInt16LE(5, valueOffset);
                                valueOffset += 2;
                                ret += terms_1.numericLiteralWriter.write(value, valueOffset, term, utils_1.separator, fpstring_1.encode(new Date(term.value).valueOf()), false);
                                valueOffset += terms_1.numericLiteralWriter.writtenValueBytes;
                                break;
                            default:
                                value.writeUInt16LE(2, valueOffset);
                                valueOffset += 2;
                                ret += terms_1.genericLiteralWriter.write(value, valueOffset, term, utils_1.separator);
                                valueOffset += terms_1.genericLiteralWriter.writtenValueBytes;
                        }
                    }
                    else {
                        value.writeUInt16LE(3, valueOffset);
                        valueOffset += 2;
                        ret += terms_1.stringLiteralWriter.write(value, valueOffset, term);
                        valueOffset += terms_1.stringLiteralWriter.writtenValueBytes;
                    }
            }
            ret += utils_1.separator;
        }
        this.writtenValueBytes = valueOffset;
        return ret;
    },
};
exports.quadReader = {
    subject: null,
    predicate: null,
    object: null,
    graph: null,
    read(key, keyOffset, value, valueOffset, termNames, factory, prefixes) {
        for (let t = 0, termName, termValue; t < termNames.length; t += 1) {
            termName = termNames[t];
            const encodedTermType = value.readUInt16LE(valueOffset);
            valueOffset += 2;
            switch (encodedTermType) {
                case 0:
                    termValue = terms_1.namedNodeReader.read(key, keyOffset, value, valueOffset, factory, prefixes);
                    keyOffset += terms_1.namedNodeReader.readKeyChars;
                    valueOffset += terms_1.namedNodeReader.readValueBytes;
                    break;
                case 1:
                    termValue = terms_1.blankNodeReader.read(key, keyOffset, value, valueOffset, factory);
                    keyOffset += terms_1.blankNodeReader.readKeyChars;
                    valueOffset += terms_1.blankNodeReader.readValueBytes;
                    break;
                case 2:
                    termValue = terms_1.genericLiteralReader.read(key, keyOffset, value, valueOffset, factory, utils_1.separator);
                    keyOffset += terms_1.genericLiteralReader.readKeyChars;
                    valueOffset += terms_1.genericLiteralReader.readValueBytes;
                    break;
                case 3:
                    termValue = terms_1.stringLiteralReader.read(key, keyOffset, value, valueOffset, factory);
                    keyOffset += terms_1.stringLiteralReader.readKeyChars;
                    valueOffset += terms_1.stringLiteralReader.readValueBytes;
                    break;
                case 4:
                    termValue = terms_1.langStringLiteralReader.read(key, keyOffset, value, valueOffset, factory, utils_1.separator);
                    keyOffset += terms_1.langStringLiteralReader.readKeyChars;
                    valueOffset += terms_1.langStringLiteralReader.readValueBytes;
                    break;
                case 5:
                    termValue = terms_1.numericLiteralReader.read(key, keyOffset, value, valueOffset, factory, utils_1.separator);
                    keyOffset += terms_1.numericLiteralReader.readKeyChars;
                    valueOffset += terms_1.numericLiteralReader.readValueBytes;
                    break;
                case 6:
                    termValue = terms_1.defaultGraphReader.read(key, keyOffset, value, valueOffset, factory);
                    keyOffset += terms_1.defaultGraphReader.readKeyChars;
                    valueOffset += terms_1.defaultGraphReader.readValueBytes;
                    break;
                default: throw new Error(`Unexpected encoded term type "${encodedTermType}"`);
            }
            this[termName] = termValue;
            keyOffset += utils_1.separator.length;
        }
        return factory.quad(this.subject, this.predicate, this.object, this.graph);
    },
};
//# sourceMappingURL=quads.js.map