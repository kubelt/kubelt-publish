import type { EventEmitter } from 'events';
import type { TSReadable, TermName, Binding } from '../types';
import { Quad, Term } from 'rdf-js';
export { flatMap } from './flatmap.js';
export { pReduce } from './p-reduce';
export { nanoid } from 'nanoid';
export declare const termNames: TermName[];
export declare const isObject: (o: any) => boolean;
export declare const streamToArray: <T>(readStream: TSReadable<T>) => Promise<T[]>;
export declare const resolveOnEvent: (emitter: EventEmitter, event: string, rejectOnError?: boolean | undefined) => Promise<any>;
export declare const waitForEvent: (emitter: EventEmitter, event: string, rejectOnError?: boolean | undefined) => Promise<any>;
export declare const defaultIndexes: TermName[][];
export declare const consumeInBatches: <T>(iterator: TSReadable<T>, batchSize: number, onEachBatch: (items: T[]) => Promise<any>) => Promise<unknown>;
export declare const consumeOneByOne: <T>(iterator: TSReadable<T>, onEachItem: (item: T) => any | Promise<any>) => Promise<void>;
export declare const pFromCallback: <T>(fn: (cb: (err: Error | undefined | null, val?: T | undefined) => void) => void) => Promise<T | undefined>;
export declare const emptyArray: any[];
export declare const emptyObject: {
    [key: string]: any;
};
export declare const boundary = "\uDBFF\uDFFF";
export declare const separator = "\0\0";
export declare const getTermComparator: () => (a: Term, b: Term) => (-1 | 0 | 1);
export declare const getQuadComparator: (_termNames?: TermName[]) => (a: Quad, b: Quad) => (-1 | 0 | 1);
export declare const getBindingComparator: (_termNames?: string[]) => (a: Binding, b: Binding) => -1 | 0 | 1;
