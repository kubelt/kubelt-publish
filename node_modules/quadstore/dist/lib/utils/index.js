"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBindingComparator = exports.getQuadComparator = exports.getTermComparator = exports.separator = exports.boundary = exports.emptyObject = exports.emptyArray = exports.pFromCallback = exports.consumeOneByOne = exports.consumeInBatches = exports.defaultIndexes = exports.waitForEvent = exports.resolveOnEvent = exports.streamToArray = exports.isObject = exports.termNames = exports.nanoid = exports.pReduce = exports.flatMap = void 0;
const asynciterator_1 = require("asynciterator");
var flatmap_js_1 = require("./flatmap.js");
Object.defineProperty(exports, "flatMap", { enumerable: true, get: function () { return flatmap_js_1.flatMap; } });
var p_reduce_1 = require("./p-reduce");
Object.defineProperty(exports, "pReduce", { enumerable: true, get: function () { return p_reduce_1.pReduce; } });
var nanoid_1 = require("nanoid");
Object.defineProperty(exports, "nanoid", { enumerable: true, get: function () { return nanoid_1.nanoid; } });
exports.termNames = [
    'subject',
    'predicate',
    'object',
    'graph',
];
const isObject = (o) => {
    return typeof (o) === 'object' && o !== null;
};
exports.isObject = isObject;
const streamToArray = (readStream) => {
    return new Promise((resolve, reject) => {
        const chunks = [];
        const onData = (chunk) => {
            chunks.push(chunk);
        };
        const onceEnd = () => {
            readStream.removeListener('data', onData);
            readStream.removeListener('error', onceError);
            resolve(chunks);
        };
        const onceError = (err) => {
            readStream.removeListener('data', onData);
            readStream.removeListener('end', onceEnd);
            readStream.destroy();
            reject(err);
        };
        readStream.once('error', onceError);
        readStream.once('end', onceEnd);
        readStream.on('data', onData);
    });
};
exports.streamToArray = streamToArray;
const resolveOnEvent = (emitter, event, rejectOnError) => {
    return new Promise((resolve, reject) => {
        const onceEvent = (arg) => {
            emitter.removeListener('error', onceError);
            resolve(arg);
        };
        const onceError = (err) => {
            emitter.removeListener(event, onceEvent);
            reject(err);
        };
        emitter.once(event, onceEvent);
        if (rejectOnError) {
            emitter.once('error', onceError);
        }
    });
};
exports.resolveOnEvent = resolveOnEvent;
exports.waitForEvent = exports.resolveOnEvent;
exports.defaultIndexes = [
    ['subject', 'predicate', 'object', 'graph'],
    ['object', 'graph', 'subject', 'predicate'],
    ['graph', 'subject', 'predicate', 'object'],
    ['subject', 'object', 'predicate', 'graph'],
    ['predicate', 'object', 'graph', 'subject'],
    ['graph', 'predicate', 'object', 'subject'],
];
class BatchingIterator extends asynciterator_1.TransformIterator {
    constructor(source, batchSize, onEachBatch) {
        super(source);
        let ind = 0;
        const buf = new Array(batchSize);
        this._transform = (item, done) => {
            buf[ind++] = item;
            if (ind < batchSize) {
                done();
                return;
            }
            ind = 0;
            onEachBatch(buf).then(done.bind(null, null)).catch(done);
        };
        this._flush = (done) => {
            if (ind === 0) {
                done();
                return;
            }
            onEachBatch(buf.slice(0, ind)).then(done.bind(null, null)).catch(done);
        };
    }
}
const consumeInBatches = async (iterator, batchSize, onEachBatch) => {
    return new Promise((resolve, reject) => {
        new BatchingIterator(iterator, batchSize, onEachBatch)
            .on('end', resolve)
            .on('error', reject);
    });
};
exports.consumeInBatches = consumeInBatches;
const consumeOneByOne = async (iterator, onEachItem) => {
    return new Promise((resolve, reject) => {
        let ended = false;
        let waiting = false;
        let working = false;
        const loop = () => {
            working = false;
            waiting = false;
            const item = iterator.read();
            if (item === null) {
                if (ended) {
                    resolve();
                }
                else {
                    waiting = true;
                    iterator.once('readable', loop);
                }
                return;
            }
            working = true;
            Promise.resolve(onEachItem(item)).then(loop).catch(reject);
        };
        iterator.once('end', () => {
            ended = true;
            if (waiting) {
                iterator.removeListener('readable', loop);
                resolve();
            }
            if (!working) {
                resolve();
            }
        });
        loop();
    });
};
exports.consumeOneByOne = consumeOneByOne;
const pFromCallback = (fn) => {
    return new Promise((resolve, reject) => {
        fn((err, val) => {
            err ? reject(err) : resolve(val);
        });
    });
};
exports.pFromCallback = pFromCallback;
exports.emptyArray = [];
exports.emptyObject = {};
exports.boundary = '\uDBFF\uDFFF';
exports.separator = '\u0000\u0000';
const getTermComparator = () => {
    return (a, b) => {
        if (a.termType !== b.termType) {
            return a.termType < b.termType ? -1 : 1;
        }
        if (a.termType !== 'Literal' || b.termType !== 'Literal') {
            return a.value < b.value ? -1 : (a.value === b.value ? 0 : 1);
        }
        if (a.language || b.language) {
            if (!a.language) {
                return -1;
            }
            if (!b.language) {
                return 1;
            }
            return a.language < b.language ? -1 : (a.language === b.language ? 0 : 1);
        }
        if (a.datatype || b.datatype) {
            if (!a.datatype) {
                return -1;
            }
            if (!b.datatype) {
                return 1;
            }
            if (a.datatype.value !== b.datatype.value) {
                return a.datatype.value < b.datatype.value ? -1 : 1;
            }
        }
        return a.value < b.value ? -1 : (a.value === b.value ? 0 : 1);
    };
};
exports.getTermComparator = getTermComparator;
const getQuadComparator = (_termNames = exports.termNames) => {
    const termComparator = exports.getTermComparator();
    return (a, b) => {
        for (let i = 0, n = _termNames.length, r; i < n; i += 1) {
            r = termComparator(a[_termNames[i]], b[_termNames[i]]);
            if (r !== 0)
                return r;
        }
        return 0;
    };
};
exports.getQuadComparator = getQuadComparator;
const getBindingComparator = (_termNames = exports.termNames) => {
    const termComparator = exports.getTermComparator();
    return (a, b) => {
        for (let i = 0, n = _termNames.length, r; i < n; i += 1) {
            r = termComparator(a[_termNames[i]], b[_termNames[i]]);
            if (r !== 0)
                return r;
        }
        return 0;
    };
};
exports.getBindingComparator = getBindingComparator;
//# sourceMappingURL=index.js.map