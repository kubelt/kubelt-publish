import { Client } from './client.js';
import {
  encodeCID,
  decodeCID
} from 'ipfs-message-port-protocol/cid';
import { decodeError } from 'ipfs-message-port-protocol/error';
import { encodeBlock } from 'ipfs-message-port-protocol/block';
export class BlockClient extends Client {
  constructor(transport) {
    super('block', [
      'put',
      'get',
      'rm',
      'stat'
    ], transport);
  }
}
BlockClient.prototype.get = async function get(cid, options = {}) {
  const {transfer} = options;
  const {block} = await this.remote.get({
    ...options,
    cid: encodeCID(cid, transfer)
  });
  return block;
};
BlockClient.prototype.put = async function put(block, options = {}) {
  const {transfer} = options;
  delete options.progress;
  const result = await this.remote.put({
    ...options,
    block: block instanceof Uint8Array ? block : encodeBlock(block, transfer)
  });
  return decodeCID(result.cid);
};
BlockClient.prototype.rm = async function* rm(cids, options = {}) {
  const {transfer} = options;
  const entries = await this.remote.rm({
    ...options,
    cids: Array.isArray(cids) ? cids.map(cid => encodeCID(cid, transfer)) : [encodeCID(cids, transfer)]
  });
  yield* entries.map(decodeRmEntry);
};
BlockClient.prototype.stat = async function stat(cid, options = {}) {
  const {transfer} = options;
  const result = await this.remote.stat({
    ...options,
    cid: encodeCID(cid, transfer)
  });
  return {
    ...result,
    cid: decodeCID(result.cid)
  };
};
const decodeRmEntry = entry => {
  const cid = decodeCID(entry.cid);
  if (entry.error) {
    return {
      cid,
      error: decodeError(entry.error)
    };
  } else {
    return { cid };
  }
};