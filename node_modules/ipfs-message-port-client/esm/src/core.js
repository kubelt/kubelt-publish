import { Client } from './client.js';
import { CID } from 'multiformats/cid';
import {
  encodeCID,
  decodeCID
} from 'ipfs-message-port-protocol/cid';
import {
  decodeIterable,
  encodeIterable,
  encodeCallback
} from 'ipfs-message-port-protocol/core';
import iterateReadableStream from 'browser-readablestream-to-it';
import {
  parseMode,
  parseMtime
} from 'ipfs-unixfs';
import itPeekable from 'it-peekable';
import errCode from 'err-code';
export class CoreClient extends Client {
  constructor(transport) {
    super('core', [
      'add',
      'addAll',
      'cat',
      'ls'
    ], transport);
  }
}
CoreClient.prototype.addAll = async function* addAll(input, options = {}) {
  const {timeout, signal} = options;
  const transfer = options.transfer || new Set();
  const progressCallback = options.progress ? encodeCallback(options.progress, transfer) : undefined;
  const result = await this.remote.addAll({
    ...options,
    input: encodeAddAllInput(input, transfer),
    progress: undefined,
    progressCallback,
    transfer,
    timeout,
    signal
  });
  yield* decodeIterable(result.data, decodeAddedData);
};
CoreClient.prototype.add = async function add(input, options = {}) {
  const {timeout, signal} = options;
  const transfer = options.transfer || new Set();
  const progressCallback = options.progress ? encodeCallback(options.progress, transfer) : undefined;
  const result = await this.remote.add({
    ...options,
    input: await encodeAddInput(input, transfer),
    progress: undefined,
    progressCallback,
    transfer,
    timeout,
    signal
  });
  return decodeAddedData(result.data);
};
CoreClient.prototype.cat = async function* cat(inputPath, options = {}) {
  const cid = CID.asCID(inputPath);
  const input = cid ? encodeCID(cid) : inputPath;
  const result = await this.remote.cat({
    ...options,
    path: input
  });
  yield* decodeIterable(result.data, identity);
};
CoreClient.prototype.ls = async function* ls(inputPath, options = {}) {
  const cid = CID.asCID(inputPath);
  const input = cid ? encodeCID(cid) : inputPath;
  const result = await this.remote.ls({
    ...options,
    path: input
  });
  yield* decodeIterable(result.data, decodeLsEntry);
};
const decodeAddedData = ({path, cid, mode, mtime, size}) => {
  return {
    path,
    cid: decodeCID(cid),
    mode,
    mtime,
    size
  };
};
const decodeLsEntry = ({name, path, size, cid, type, mode, mtime}) => ({
  cid: decodeCID(cid),
  type,
  name,
  path,
  mode,
  mtime,
  size
});
const identity = v => v;
const encodeAddInput = async (input, transfer) => {
  if (input instanceof Blob) {
    return input;
  } else if (typeof input === 'string') {
    return input;
  } else if (input instanceof ArrayBuffer) {
    return input;
  } else if (ArrayBuffer.isView(input)) {
    return input;
  } else {
    const iterable = asIterable(input);
    if (iterable) {
      return encodeIterable(await ensureIsByteStream(iterable), encodeIterableContent, transfer);
    }
    const asyncIterable = asAsyncIterable(input);
    if (asyncIterable) {
      return encodeIterable(await ensureIsByteStream(asyncIterable), encodeAsyncIterableContent, transfer);
    }
    const readableStream = asReadableStream(input);
    if (readableStream) {
      return encodeIterable(await ensureIsByteStream(iterateReadableStream(readableStream)), encodeAsyncIterableContent, transfer);
    }
    const file = asFileObject(input);
    if (file) {
      return encodeFileObject(file, transfer);
    }
    throw TypeError('Unexpected input: ' + typeof input);
  }
};
const encodeAddAllInput = (input, transfer) => {
  const iterable = asIterable(input);
  if (iterable) {
    return encodeIterable(iterable, encodeIterableContent, transfer);
  }
  const asyncIterable = asAsyncIterable(input);
  if (asyncIterable) {
    return encodeIterable(asyncIterable, encodeAsyncIterableContent, transfer);
  }
  const readableStream = asReadableStream(input);
  if (readableStream) {
    return encodeIterable(iterateReadableStream(readableStream), encodeAsyncIterableContent, transfer);
  }
  throw TypeError('Unexpected input: ' + typeof input);
};
const encodeAsyncIterableContent = (content, transfer) => {
  if (content instanceof ArrayBuffer) {
    return content;
  } else if (ArrayBuffer.isView(content)) {
    return content;
  } else if (content instanceof Blob) {
    return {
      path: '',
      content
    };
  } else if (typeof content === 'string') {
    return {
      path: '',
      content
    };
  } else {
    const file = asFileObject(content);
    if (file) {
      return encodeFileObject(file, transfer);
    } else {
      throw TypeError('Unexpected input: ' + typeof content);
    }
  }
};
const encodeIterableContent = (content, transfer) => {
  if (typeof content === 'number') {
    throw TypeError('Iterable of numbers is not supported');
  } else if (content instanceof ArrayBuffer) {
    return content;
  } else if (ArrayBuffer.isView(content)) {
    return content;
  } else if (content instanceof Blob) {
    return {
      path: '',
      content
    };
  } else if (typeof content === 'string') {
    return {
      path: '',
      content
    };
  } else {
    const file = asFileObject(content);
    if (file) {
      return encodeFileObject(file, transfer);
    } else {
      throw TypeError('Unexpected input: ' + typeof content);
    }
  }
};
const encodeFileObject = ({path, mode, mtime, content}, transfer) => {
  const output = {
    path,
    mode: parseMode(mode),
    mtime: parseMtime(mtime)
  };
  if (content) {
    output.content = encodeFileContent(content, transfer);
  }
  return output;
};
const encodeFileContent = (content, transfer) => {
  if (content == null) {
    return '';
  } else if (content instanceof ArrayBuffer || ArrayBuffer.isView(content)) {
    return content;
  } else if (content instanceof Blob) {
    return content;
  } else if (typeof content === 'string') {
    return content;
  } else {
    const iterable = asIterable(content);
    if (iterable) {
      return encodeIterable(iterable, encodeIterableContent, transfer);
    }
    const asyncIterable = asAsyncIterable(content);
    if (asyncIterable) {
      return encodeIterable(asyncIterable, encodeAsyncIterableContent, transfer);
    }
    const readableStream = asReadableStream(content);
    if (readableStream) {
      return encodeIterable(iterateReadableStream(readableStream), encodeAsyncIterableContent, transfer);
    }
    throw TypeError('Unexpected input: ' + typeof content);
  }
};
const asIterable = input => {
  const object = input;
  if (object && typeof object[Symbol.iterator] === 'function') {
    return object;
  } else {
    return null;
  }
};
const asAsyncIterable = input => {
  const object = input;
  if (object && typeof object[Symbol.asyncIterator] === 'function') {
    return object;
  } else {
    return null;
  }
};
const asReadableStream = input => {
  if (input && typeof input.getReader === 'function') {
    return input;
  } else {
    return null;
  }
};
const asFileObject = input => {
  if (typeof input === 'object' && (input.path || input.content)) {
    return input;
  } else {
    return null;
  }
};
const ensureIsByteStream = async input => {
  const peekable = itPeekable(input);
  const {value, done} = await peekable.peek();
  if (done) {
    return [];
  }
  peekable.push(value);
  if (Number.isInteger(value) || isBytes(value) || typeof value === 'string' || value instanceof String) {
    return peekable;
  }
  throw errCode(new Error('Unexpected input: multiple items passed - if you are using ipfs.add, please use ipfs.addAll instead'), 'ERR_UNEXPECTED_INPUT');
};
function isBytes(obj) {
  return ArrayBuffer.isView(obj) || obj instanceof ArrayBuffer;
}