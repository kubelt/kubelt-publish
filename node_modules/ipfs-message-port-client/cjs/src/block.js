'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var client = require('./client.js');
var cid = require('ipfs-message-port-protocol/cid');
var error = require('ipfs-message-port-protocol/error');
var block = require('ipfs-message-port-protocol/block');

class BlockClient extends client.Client {
  constructor(transport) {
    super('block', [
      'put',
      'get',
      'rm',
      'stat'
    ], transport);
  }
}
BlockClient.prototype.get = async function get(cid$1, options = {}) {
  const {transfer} = options;
  const {block} = await this.remote.get({
    ...options,
    cid: cid.encodeCID(cid$1, transfer)
  });
  return block;
};
BlockClient.prototype.put = async function put(block$1, options = {}) {
  const {transfer} = options;
  delete options.progress;
  const result = await this.remote.put({
    ...options,
    block: block$1 instanceof Uint8Array ? block$1 : block.encodeBlock(block$1, transfer)
  });
  return cid.decodeCID(result.cid);
};
BlockClient.prototype.rm = async function* rm(cids, options = {}) {
  const {transfer} = options;
  const entries = await this.remote.rm({
    ...options,
    cids: Array.isArray(cids) ? cids.map(cid$1 => cid.encodeCID(cid$1, transfer)) : [cid.encodeCID(cids, transfer)]
  });
  yield* entries.map(decodeRmEntry);
};
BlockClient.prototype.stat = async function stat(cid$1, options = {}) {
  const {transfer} = options;
  const result = await this.remote.stat({
    ...options,
    cid: cid.encodeCID(cid$1, transfer)
  });
  return {
    ...result,
    cid: cid.decodeCID(result.cid)
  };
};
const decodeRmEntry = entry => {
  const cid$1 = cid.decodeCID(entry.cid);
  if (entry.error) {
    return {
      cid: cid$1,
      error: error.decodeError(entry.error)
    };
  } else {
    return { cid: cid$1 };
  }
};

exports.BlockClient = BlockClient;
