'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var client = require('./client.js');
var cid = require('multiformats/cid');
var cid$1 = require('ipfs-message-port-protocol/cid');
var core = require('ipfs-message-port-protocol/core');
var iterateReadableStream = require('browser-readablestream-to-it');
var ipfsUnixfs = require('ipfs-unixfs');
var itPeekable = require('it-peekable');
var errCode = require('err-code');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var iterateReadableStream__default = /*#__PURE__*/_interopDefaultLegacy(iterateReadableStream);
var itPeekable__default = /*#__PURE__*/_interopDefaultLegacy(itPeekable);
var errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);

class CoreClient extends client.Client {
  constructor(transport) {
    super('core', [
      'add',
      'addAll',
      'cat',
      'ls'
    ], transport);
  }
}
CoreClient.prototype.addAll = async function* addAll(input, options = {}) {
  const {timeout, signal} = options;
  const transfer = options.transfer || new Set();
  const progressCallback = options.progress ? core.encodeCallback(options.progress, transfer) : undefined;
  const result = await this.remote.addAll({
    ...options,
    input: encodeAddAllInput(input, transfer),
    progress: undefined,
    progressCallback,
    transfer,
    timeout,
    signal
  });
  yield* core.decodeIterable(result.data, decodeAddedData);
};
CoreClient.prototype.add = async function add(input, options = {}) {
  const {timeout, signal} = options;
  const transfer = options.transfer || new Set();
  const progressCallback = options.progress ? core.encodeCallback(options.progress, transfer) : undefined;
  const result = await this.remote.add({
    ...options,
    input: await encodeAddInput(input, transfer),
    progress: undefined,
    progressCallback,
    transfer,
    timeout,
    signal
  });
  return decodeAddedData(result.data);
};
CoreClient.prototype.cat = async function* cat(inputPath, options = {}) {
  const cid$2 = cid.CID.asCID(inputPath);
  const input = cid$2 ? cid$1.encodeCID(cid$2) : inputPath;
  const result = await this.remote.cat({
    ...options,
    path: input
  });
  yield* core.decodeIterable(result.data, identity);
};
CoreClient.prototype.ls = async function* ls(inputPath, options = {}) {
  const cid$2 = cid.CID.asCID(inputPath);
  const input = cid$2 ? cid$1.encodeCID(cid$2) : inputPath;
  const result = await this.remote.ls({
    ...options,
    path: input
  });
  yield* core.decodeIterable(result.data, decodeLsEntry);
};
const decodeAddedData = ({path, cid, mode, mtime, size}) => {
  return {
    path,
    cid: cid$1.decodeCID(cid),
    mode,
    mtime,
    size
  };
};
const decodeLsEntry = ({name, path, size, cid, type, mode, mtime}) => ({
  cid: cid$1.decodeCID(cid),
  type,
  name,
  path,
  mode,
  mtime,
  size
});
const identity = v => v;
const encodeAddInput = async (input, transfer) => {
  if (input instanceof Blob) {
    return input;
  } else if (typeof input === 'string') {
    return input;
  } else if (input instanceof ArrayBuffer) {
    return input;
  } else if (ArrayBuffer.isView(input)) {
    return input;
  } else {
    const iterable = asIterable(input);
    if (iterable) {
      return core.encodeIterable(await ensureIsByteStream(iterable), encodeIterableContent, transfer);
    }
    const asyncIterable = asAsyncIterable(input);
    if (asyncIterable) {
      return core.encodeIterable(await ensureIsByteStream(asyncIterable), encodeAsyncIterableContent, transfer);
    }
    const readableStream = asReadableStream(input);
    if (readableStream) {
      return core.encodeIterable(await ensureIsByteStream(iterateReadableStream__default["default"](readableStream)), encodeAsyncIterableContent, transfer);
    }
    const file = asFileObject(input);
    if (file) {
      return encodeFileObject(file, transfer);
    }
    throw TypeError('Unexpected input: ' + typeof input);
  }
};
const encodeAddAllInput = (input, transfer) => {
  const iterable = asIterable(input);
  if (iterable) {
    return core.encodeIterable(iterable, encodeIterableContent, transfer);
  }
  const asyncIterable = asAsyncIterable(input);
  if (asyncIterable) {
    return core.encodeIterable(asyncIterable, encodeAsyncIterableContent, transfer);
  }
  const readableStream = asReadableStream(input);
  if (readableStream) {
    return core.encodeIterable(iterateReadableStream__default["default"](readableStream), encodeAsyncIterableContent, transfer);
  }
  throw TypeError('Unexpected input: ' + typeof input);
};
const encodeAsyncIterableContent = (content, transfer) => {
  if (content instanceof ArrayBuffer) {
    return content;
  } else if (ArrayBuffer.isView(content)) {
    return content;
  } else if (content instanceof Blob) {
    return {
      path: '',
      content
    };
  } else if (typeof content === 'string') {
    return {
      path: '',
      content
    };
  } else {
    const file = asFileObject(content);
    if (file) {
      return encodeFileObject(file, transfer);
    } else {
      throw TypeError('Unexpected input: ' + typeof content);
    }
  }
};
const encodeIterableContent = (content, transfer) => {
  if (typeof content === 'number') {
    throw TypeError('Iterable of numbers is not supported');
  } else if (content instanceof ArrayBuffer) {
    return content;
  } else if (ArrayBuffer.isView(content)) {
    return content;
  } else if (content instanceof Blob) {
    return {
      path: '',
      content
    };
  } else if (typeof content === 'string') {
    return {
      path: '',
      content
    };
  } else {
    const file = asFileObject(content);
    if (file) {
      return encodeFileObject(file, transfer);
    } else {
      throw TypeError('Unexpected input: ' + typeof content);
    }
  }
};
const encodeFileObject = ({path, mode, mtime, content}, transfer) => {
  const output = {
    path,
    mode: ipfsUnixfs.parseMode(mode),
    mtime: ipfsUnixfs.parseMtime(mtime)
  };
  if (content) {
    output.content = encodeFileContent(content, transfer);
  }
  return output;
};
const encodeFileContent = (content, transfer) => {
  if (content == null) {
    return '';
  } else if (content instanceof ArrayBuffer || ArrayBuffer.isView(content)) {
    return content;
  } else if (content instanceof Blob) {
    return content;
  } else if (typeof content === 'string') {
    return content;
  } else {
    const iterable = asIterable(content);
    if (iterable) {
      return core.encodeIterable(iterable, encodeIterableContent, transfer);
    }
    const asyncIterable = asAsyncIterable(content);
    if (asyncIterable) {
      return core.encodeIterable(asyncIterable, encodeAsyncIterableContent, transfer);
    }
    const readableStream = asReadableStream(content);
    if (readableStream) {
      return core.encodeIterable(iterateReadableStream__default["default"](readableStream), encodeAsyncIterableContent, transfer);
    }
    throw TypeError('Unexpected input: ' + typeof content);
  }
};
const asIterable = input => {
  const object = input;
  if (object && typeof object[Symbol.iterator] === 'function') {
    return object;
  } else {
    return null;
  }
};
const asAsyncIterable = input => {
  const object = input;
  if (object && typeof object[Symbol.asyncIterator] === 'function') {
    return object;
  } else {
    return null;
  }
};
const asReadableStream = input => {
  if (input && typeof input.getReader === 'function') {
    return input;
  } else {
    return null;
  }
};
const asFileObject = input => {
  if (typeof input === 'object' && (input.path || input.content)) {
    return input;
  } else {
    return null;
  }
};
const ensureIsByteStream = async input => {
  const peekable = itPeekable__default["default"](input);
  const {value, done} = await peekable.peek();
  if (done) {
    return [];
  }
  peekable.push(value);
  if (Number.isInteger(value) || isBytes(value) || typeof value === 'string' || value instanceof String) {
    return peekable;
  }
  throw errCode__default["default"](new Error('Unexpected input: multiple items passed - if you are using ipfs.add, please use ipfs.addAll instead'), 'ERR_UNEXPECTED_INPUT');
};
function isBytes(obj) {
  return ArrayBuffer.isView(obj) || obj instanceof ArrayBuffer;
}

exports.CoreClient = CoreClient;
