'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var error$1 = require('ipfs-message-port-protocol/error');
var error = require('./error.js');

class MessageTransport {
  constructor(port) {
    this.port = null;
    this.id = Math.random().toString(32).slice(2);
    this.nextID = 0;
    this.queries = Object.create(null);
    if (port) {
      this.connect(port);
    }
  }
  execute(query) {
    const id = `${ this.id }@${ this.nextID++ }`;
    this.queries[id] = query;
    if (query.timeout > 0 && query.timeout < Infinity) {
      query.timerID = setTimeout(MessageTransport.timeout, query.timeout, this, id);
    }
    if (query.signal) {
      query.signal.addEventListener('abort', () => this.abort(id), { once: true });
    }
    if (this.port) {
      MessageTransport.postQuery(this.port, id, query);
    }
    return query.result;
  }
  connect(port) {
    if (this.port) {
      throw new Error('Transport is already open');
    } else {
      this.port = port;
      this.port.addEventListener('message', this);
      this.port.start();
      for (const [id, query] of Object.entries(this.queries)) {
        MessageTransport.postQuery(port, id, query);
      }
    }
  }
  disconnect() {
    const error$1 = new error.DisconnectError();
    for (const [id, query] of Object.entries(this.queries)) {
      query.fail(error$1);
      this.abort(id);
    }
    if (this.port) {
      this.port.removeEventListener('message', this);
      this.port.close();
    }
  }
  static timeout(self, id) {
    const {queries} = self;
    const query = queries[id];
    if (query) {
      delete queries[id];
      query.fail(new error.TimeoutError('request timed out'));
      if (self.port) {
        self.port.postMessage({
          type: 'abort',
          id
        });
      }
    }
  }
  abort(id) {
    const {queries} = this;
    const query = queries[id];
    if (query) {
      delete queries[id];
      query.fail(new error.AbortError());
      if (this.port) {
        this.port.postMessage({
          type: 'abort',
          id
        });
      }
      if (query.timerID != null) {
        clearTimeout(query.timerID);
      }
    }
  }
  static postQuery(port, id, query) {
    port.postMessage({
      type: 'query',
      namespace: query.namespace,
      method: query.method,
      id,
      input: query.toJSON()
    }, query.transfer());
  }
  handleEvent(event) {
    const {id, result} = event.data;
    const query = this.queries[id];
    if (query) {
      delete this.queries[id];
      if (result.ok) {
        query.succeed(result.value);
      } else {
        query.fail(error$1.decodeError(result.error));
      }
      if (query.timerID != null) {
        clearTimeout(query.timerID);
      }
    }
  }
}

exports.MessageTransport = MessageTransport;
