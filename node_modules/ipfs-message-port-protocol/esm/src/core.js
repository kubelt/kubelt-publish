import {
  encodeError,
  decodeError
} from './error.js';
export const decodeIterable = async function* ({port}, decode) {
  let receive = _data => {
  };
  const wait = () => new Promise(resolve => receive = resolve);
  const next = () => {
    port.postMessage({ method: 'next' });
    return wait();
  };
  port.onmessage = event => receive(event.data);
  let isDone = false;
  try {
    while (!isDone) {
      const {done, value, error} = await next();
      isDone = done;
      if (error != null) {
        throw decodeError(error);
      } else if (value != null) {
        yield decode(value);
      }
    }
  } finally {
    if (!isDone) {
      port.postMessage({ method: 'return' });
    }
    port.close();
  }
};
export const encodeIterable = (iterable, encode, transfer) => {
  const {
    port1: port,
    port2: remote
  } = new MessageChannel();
  const iterator = toIterator(iterable);
  const itemTransfer = new Set();
  port.onmessage = async ({
    data: {method}
  }) => {
    switch (method) {
    case 'next': {
        try {
          const {done, value} = await iterator.next();
          if (done) {
            port.postMessage({
              type: 'next',
              done: true
            });
            port.close();
          } else {
            itemTransfer.clear();
            const encodedValue = encode(value, itemTransfer);
            postMessage(port, {
              type: 'next',
              done: false,
              value: encodedValue
            }, itemTransfer);
          }
        } catch (error) {
          port.postMessage({
            type: 'throw',
            error: encodeError(error)
          });
          port.close();
        }
        break;
      }
    case 'return': {
        port.close();
        if (iterator.return) {
          iterator.return();
        }
        break;
      }
    default: {
        break;
      }
    }
  };
  port.start();
  transfer.add(remote);
  return {
    type: 'RemoteIterable',
    port: remote
  };
};
const toIterator = iterable => {
  if (iterable != null) {
    if (typeof iterable[Symbol.asyncIterator] === 'function') {
      return iterable[Symbol.asyncIterator]();
    }
    if (typeof iterable[Symbol.iterator] === 'function') {
      return iterable[Symbol.iterator]();
    }
  }
  throw TypeError('Value must be async or sync iterable');
};
export const encodeCallback = (callback, transfer) => {
  const {
    port1: port,
    port2: remote
  } = new MessageChannel();
  port.onmessage = ({data}) => callback.apply(null, data);
  transfer.add(remote);
  return {
    type: 'RemoteCallback',
    port: remote
  };
};
export const decodeCallback = ({port}) => {
  const callback = (args, transfer) => {
    postMessage(port, args, transfer);
  };
  return callback;
};
const postMessage = (port, message, transfer) => port.postMessage(message, transfer);